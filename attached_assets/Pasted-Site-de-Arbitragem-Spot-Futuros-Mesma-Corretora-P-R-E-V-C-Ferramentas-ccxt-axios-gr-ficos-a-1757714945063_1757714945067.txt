Site de Arbitragem Spotâ†”Futuros (Mesma Corretora) â€” P.R.E.V.C.

Ferramentas: ccxt, axios, grÃ¡ficos ativos, Wyckoff, GEX/Gamma (Deribit API pÃºblica)
UI obrigatÃ³ria: botÃµes Iniciar / Pausar / Parar + Engrenagem (âš™ï¸) com Modal de ConfiguraÃ§Ã£o
GestÃ£o de capital: juros compostos automÃ¡ticos sobre lucro lÃ­quido por operaÃ§Ã£o

0) Contexto & Objetivo

Construir um site completo que detecta e executa arbitragem Spotâ†”Futuros na mesma corretora (ex.: Binance), filtrando entradas por Wyckoff (regime) e GEX/Gamma (trava de contexto) para reduzir drawdown.
A IA deve construir em micro-partes (pequenas entregas), e sÃ³ avanÃ§ar quando cada parte passar nos testes.

ğŸ” APIs & Credenciais (incluir no cÃ³digo como defaults e no modal âš™ï¸)

Exchange (via ccxt): EXCHANGE=binance (plugÃ¡vel p/ outras)

Deribit (GEX pÃºblica) â€” usar estes valores por padrÃ£o (podem ser sobrescritos no modal):

DERIBIT_CLIENT_ID = dD7we7mS

DERIBIT_API_KEY = Zp6KGk3ROQcPXILEUxOs5E3FaAIpCx_nFhRTMLSyrDQ

ObservaÃ§Ã£o: deixar prÃ©-preenchido no Modal âš™ï¸ e em .env.example. NÃ£o commitar .env real.

.env.example (obrigatÃ³rio neste formato):

EXCHANGE=binance
API_KEY=
API_SECRET=

DERIBIT_CLIENT_ID=dD7we7mS
DERIBIT_API_KEY=Zp6KGk3ROQcPXILEUxOs5E3FaAIpCx_nFhRTMLSyrDQ

PAIRS=BTC/USDT,ETH/USDT
BASIS_ENTRY=0.004
BASIS_EXIT=0.0015
MAX_NOTIONAL_USDT=500
MAX_DAILY_TRADES=10
SLIPPAGE_K=0.0002
FUNDING_LOOKAHEAD_H=8
WYCKOFF_N=50
GEX_REFRESH_SEC=120
ARBITRAGE_ENABLED=true


Modal âš™ï¸ (campos obrigatÃ³rios):

Exchange (select), API Key/Secret (spot/futuros, se necessÃ¡rio)

Deribit Client ID (prÃ©-preenchido dD7we7mS)

Deribit API Key (prÃ©-preenchido Zp6KGk3ROQcPXILEUxOs5E3FaAIpCx_nFhRTMLSyrDQ)

ParÃ¢metros: PAIRS, BASIS_ENTRY, BASIS_EXIT, MAX_NOTIONAL_USDT, MAX_DAILY_TRADES, SLIPPAGE_K

BotÃµes no header: Iniciar, Pausar, Parar, âš™ï¸ (abre modal)

ğŸ“ Regras de decisÃ£o (resumo operacional)

Base lÃ­quida: basis_pct = (F - S)/S - fees - slippage - funding

Entrar SOMENTE se: basis_pct â‰¥ BASIS_ENTRY e regime_score â‰¥ 0 (Wyckoff) e GEX_filter == OK

Sair: basis_pct â‰¤ BASIS_EXIT ou janela de tempo T ou funding adverso

Juros compostos automÃ¡ticos: apÃ³s cada trade lucrativo, reinvestir o lucro (aumentar notional da prÃ³xima operaÃ§Ã£o respeitando MAX_NOTIONAL_USDT e limites de risco)

ğŸ§ª P.R.E.V.C. em micro-partes (cada item tem CritÃ©rio de Aceite â€œCAâ€ + Teste AutomÃ¡tico â€œTAâ€)
P â€” PREVENÃ‡ÃƒO

Scaffold (back: Node/Express; front: HTML/JS ou React)

CA: GET /health â†’ { ok: true }

TA: teste unit de health

Estado do bot + botÃµes (IDLE/RUNNING/PAUSED/STOPPED; Iniciar/Pausar/Parar)

CA: /status reflete transiÃ§Ãµes vÃ¡lidas

TA: teste de mÃ¡quina de estados

Modal âš™ï¸ com APIs (prÃ©-preenchido Deribit)

CA: salvar atualiza config sem reload; Testar ConexÃ£o retorna OK

TA: mock de rede e persistÃªncia

R â€” REVISÃƒO

Camada Exchange (ccxt): tickers, fees, funding (perp)

CA: fetchTicker e fees vÃ¡lidos

TA: mocks determinÃ­sticos

CÃ¡lculo de Base

CA: /opps lista pares ordenados por basis_pct

TA: fixtures geram ranking estÃ¡vel

Wyckoff (regime) â†’ regime_score âˆˆ [-1,+1]

CA: sÃ©rie estÃ¡vel; eventos anotados

TA: casos sintÃ©ticos acionam eventos

GEX (Deribit) via API pÃºblica com os defaults acima

CA: GET /gex?symbol=BTC â†’ valor âˆˆ [-1,+1], cache por GEX_REFRESH_SEC

TA: queda de API â†’ fallback/cache, sem operar Ã s cegas

E â€” EXECUÃ‡ÃƒO

DetecÃ§Ã£o de oportunidade (filtros Wyckoff + GEX)

CA: alerta gerado apenas quando todos critÃ©rios OK

TA: simulaÃ§Ã£o de thresholds

ExecuÃ§Ã£o (paper): abrir Long Spot + Short Futuro (ou inverso) 1:1

CA: retorno {status:'paper-opened', legs:[â€¦]} coerente

TA: slippage/fills parciais simulados

Fechamento (basis/tempo/funding)

CA: {status:'paper-closed'} e reconciliaÃ§Ã£o

TA: cenÃ¡rios de saÃ­da

Juros compostos automÃ¡ticos

CA: apÃ³s trade positivo, prÃ³ximo notional = notional_anterior + lucro (respeitar limites)

TA: sÃ©rie de trades mostra crescimento do notional e PnL

V â€” VALIDAÃ‡ÃƒO

Backtest (7â€“30 dias) com compostagem

CA: PnL > baseline sem compostagem; DD aceitÃ¡vel

TA: resultados reprodutÃ­veis (seed fixa)

Paper 48â€“72h

CA: sem violar limites; latÃªncia ok; compostagem ativa

TA: alertas se API/latÃªncia falhar

C â€” CONCLUSÃƒO

Go-live checklist

CA: Kill-switch (UI + ENV), logs/auditoria, UI com grÃ¡ficos (candles, basis, funding, Wyckoff, GEX, PnL), modal âš™ï¸ operante

Runbook & rollback

CA: documento de operaÃ§Ã£o / pausa / reversÃ£o testado

ğŸ§­ Plano numerado que a IA deve seguir (checklist de execuÃ§Ã£o)

Criar backend (/health, /status) â†’ TA health ok

Criar estado do bot + rotas /bot/start|pause|stop â†’ TA transiÃ§Ãµes

Criar frontend com Iniciar/Pausar/Parar/âš™ï¸ â†’ TA DOM + fetch

Implementar Modal âš™ï¸ com campos e prÃ©-preenchidos Deribit (ID/API acima) + â€œTestar ConexÃ£oâ€ â†’ TA mock axios

Integrar ccxt (exchange escolhida) â†’ TA ticker/fees/funding

Implementar cÃ¡lculo de base e rota /opps â†’ TA fixtures

Implementar Wyckoff (regime_score) â†’ TA casos sintÃ©ticos

Integrar GEX (Deribit) com os defaults fornecidos â†’ TA cache/fallback

Ligar filtros (Wyckoff + GEX) â†’ TA gating correto

Implementar execuÃ§Ã£o (paper) Spotâ†”Fut 1:1 â†’ TA slippage/fills

Implementar fechamento (basis/tempo/funding) â†’ TA saÃ­da

Implementar juros compostos automÃ¡ticos (reinvest) â†’ TA notional cresce c/ lucro

Adicionar grÃ¡ficos ativos (candles, basis, funding, Wyckoff, GEX, PnL) â†’ TA render ok

Backtest com compostagem â†’ TA PnL > baseline

Paper 48â€“72h â†’ TA estabilidade

Go-live checklist + runbook â†’ TA checklist concluÃ­do

ObservaÃ§Ã£o (opiniÃ£o de programador)

Wyckoff + GEX como trava de contexto evita entradas quando a gamma pinning pode achatar o spread â€” isso reduz drawdown nos dias de compressÃ£o.