// üöÄ EXCHANGE API - APENAS DADOS REAIS
// Produ√ß√£o exclusiva com dados reais da Binance

import WebSocket from 'ws';
import { makeSpotExchange, makeFuturesExchange, makeFetch, getNetworkStatus } from './net.js';
import { fetchWithKillSwitch } from './exchange-manager.js';

export interface MarketData {
  symbol: string;
  spotPrice: number;
  futuresPrice: number;
  basis: number;
  basisPercent: number;
  fundingRate: number;
  volume24h: number;
  timestamp: number;
}

export interface OrderBookData {
  symbol: string;
  bids: [number, number][];
  asks: [number, number][];
  timestamp: number;
}

/**
 * üî• EXCHANGE API - APENAS DADOS REAIS DE PRODU√á√ÉO
 */
export class ExchangeAPI {
  private spotExchange: any;
  private futuresExchange: any;
  private wsConnections: Map<string, WebSocket> = new Map();
  private marketDataCallbacks: Map<string, (data: MarketData) => void> = new Map();
  private orderBookCallbacks: Map<string, (data: OrderBookData) => void> = new Map();
  
  // üõ°Ô∏è CACHE PARA OTIMIZA√á√ÉO
  private priceCache = new Map<string, { price: number; timestamp: number; ttl: number }>();
  private readonly CACHE_TTL_MS = 30000; // Cache 30 segundos
  private lastApiCall = 0;
  private readonly MIN_INTERVAL_MS = 100; // M√≠nimo 100ms entre chamadas

  constructor() {
    console.log('üöÄ Inicializando ExchangeAPI para produ√ß√£o...');
    
    const networkStatus = getNetworkStatus();
    console.log('üåê Network Status:', networkStatus);
    
    try {
      // üî• CRIAR EXCHANGES USANDO NET.JS
      this.spotExchange = makeSpotExchange();
      this.futuresExchange = makeFuturesExchange();
      
      console.log('‚úÖ ExchangeAPI inicializado para produ√ß√£o');
      if (networkStatus.proxyEnabled) {
        console.log(`üîß Usando proxy: ${networkStatus.proxyUrl}`);
      } else {
        console.log('üåê Conex√£o DIRETA (sem proxy)');
      }
      
    } catch (error) {
      console.error('‚ùå Erro inicializando ExchangeAPI:', error.message);
      throw error;
    }
  }

  // üõ°Ô∏è M√âTODOS DE CACHE
  private getCachedPrice(symbol: string): number | null {
    const cached = this.priceCache.get(symbol);
    if (cached && Date.now() < cached.ttl) {
      return cached.price;
    }
    return null;
  }
  
  private setCachedPrice(symbol: string, price: number): void {
    this.priceCache.set(symbol, {
      price,
      timestamp: Date.now(),
      ttl: Date.now() + this.CACHE_TTL_MS
    });
  }
  
  private async waitForRateLimit(): Promise<void> {
    const now = Date.now();
    const timeSinceLastCall = now - this.lastApiCall;
    
    if (timeSinceLastCall < this.MIN_INTERVAL_MS) {
      const waitTime = this.MIN_INTERVAL_MS - timeSinceLastCall;
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    this.lastApiCall = Date.now();
  }

  // üßπ LIMPAR CACHE
  clearCache(): void {
    console.log('üßπ Limpando cache de pre√ßos...');
    this.priceCache.clear();
    console.log('‚úÖ Cache limpo');
  }

  async initialize(): Promise<void> {
    try {
      console.log('üîç Testando conectividade com Binance...');
      
      // Testar com BTC/USDT - s√≠mbolo mais est√°vel
      const ticker = await this.spotExchange.fetchTicker('BTC/USDT');
      console.log('‚úÖ Conectividade OK! BTC/USDT price:', ticker.last);
      console.log('üéØ Modo: PRODU√á√ÉO - DADOS REAIS');
      
    } catch (error) {
      console.error('‚ùå Falha na conectividade com Binance:', error.message);
      throw new Error(`N√£o foi poss√≠vel conectar √† Binance: ${error.message}`);
    }
  }

  // üìä BUSCAR PRE√áO SPOT - APENAS DADOS REAIS
  async getSpotPrice(symbol: string): Promise<number> {
    try {
      // üî• VERIFICAR CACHE PRIMEIRO
      const cachedPrice = this.getCachedPrice(`spot_${symbol}`);
      if (cachedPrice !== null) {
        return cachedPrice;
      }
      
      await this.waitForRateLimit();
      
      try {
        const ticker = await this.spotExchange.fetchTicker(symbol);
        
        if (!ticker || !ticker.last) {
          throw new Error(`Pre√ßo spot n√£o dispon√≠vel para ${symbol}`);
        }
        
        const price = parseFloat(ticker.last.toString());
        console.log(`‚úÖ ${symbol}: Pre√ßo spot $${price.toFixed(4)} (CCXT)`);
        
        this.setCachedPrice(`spot_${symbol}`, price);
        return price;
        
      } catch (ccxtError) {
        // Fallback: API p√∫blica Binance com data.binance.com primeiro
        console.log(`üîÑ Fallback: API p√∫blica para ${symbol}`);
        
        const binanceSymbol = symbol.replace('/', '');
        
        // Tenta primeiro data.binance.com (menos restritivo para geoblocking)
        try {
          const response = await makeFetch(`https://data.binance.com/api/v3/ticker/24hr?symbol=${binanceSymbol}`);
          if (response.ok) {
            const data = await response.json();
            const price = parseFloat(data.lastPrice);
            
            if (price && price > 0) {
              console.log(`‚úÖ ${symbol}: Pre√ßo spot $${price.toFixed(4)} (data.binance.com)`);
              this.setCachedPrice(`spot_${symbol}`, price);
              return price;
            }
          }
        } catch (dataError) {
          console.log(`‚ö†Ô∏è data.binance.com falhou para ${symbol}, tentando api.binance.com`);
        }
        
        // Fallback para api.binance.com
        const response = await makeFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${binanceSymbol}`);
        
        if (!response.ok) {
          throw new Error(`Falha na API Binance: ${response.status}`);
        }
        
        const data = await response.json();
        const price = parseFloat(data.lastPrice);
        
        if (!price || price <= 0) {
          throw new Error(`Pre√ßo inv√°lido recebido para ${symbol}: ${price}`);
        }
        
        console.log(`‚úÖ ${symbol}: Pre√ßo spot $${price.toFixed(4)} (API P√∫blica)`);
        
        this.setCachedPrice(`spot_${symbol}`, price);
        return price;
      }
    } catch (error) {
      console.error(`‚ùå Erro ao buscar pre√ßo spot para ${symbol}:`, error.message);
      throw error;
    }
  }

  // üíé BUSCAR PRE√áO FUTURES - APENAS DADOS REAIS
  async getFuturesPrice(symbol: string): Promise<number> {
    try {
      // üî• VERIFICAR CACHE PRIMEIRO
      const cachedPrice = this.getCachedPrice(`futures_${symbol}`);
      if (cachedPrice !== null) {
        return cachedPrice;
      }
      
      await this.waitForRateLimit();
      
      const futuresSymbol = this.convertToFuturesSymbol(symbol);
      
      try {
        const ticker = await this.futuresExchange.fetchTicker(futuresSymbol);
        
        if (!ticker || !ticker.last) {
          throw new Error(`Pre√ßo futures n√£o dispon√≠vel para ${futuresSymbol}`);
        }
        
        const price = parseFloat(ticker.last.toString());
        console.log(`‚úÖ ${futuresSymbol}: Pre√ßo futures $${price.toFixed(6)} (CCXT)`);
        
        this.setCachedPrice(`futures_${symbol}`, price);
        return price;
        
      } catch (ccxtError) {
        // Fallback: API p√∫blica Binance Futures
        console.log(`üîÑ Fallback: API p√∫blica futures para ${futuresSymbol}`);
        
        const binanceSymbol = symbol.replace('/', '');
        const response = await makeFetch(`https://fapi.binance.com/fapi/v1/ticker/24hr?symbol=${binanceSymbol}`);
        
        if (!response.ok) {
          // Se for erro 400, o s√≠mbolo provavelmente n√£o existe
          if (response.status === 400) {
            console.log(`‚ö†Ô∏è S√≠mbolo futures ${symbol} n√£o encontrado (400)`);
            throw new Error(`S√≠mbolo futures n√£o encontrado: ${symbol}`);
          }
          throw new Error(`Falha na API Binance Futures: ${response.status}`);
        }
        
        const data = await response.json();
        const price = parseFloat(data.lastPrice);
        
        if (!price || price <= 0 || isNaN(price)) {
          console.log(`‚ö†Ô∏è Pre√ßo futures inv√°lido para ${symbol}: ${price}`);
          throw new Error(`Pre√ßo futures inv√°lido recebido para ${symbol}: ${price}`);
        }
        
        console.log(`‚úÖ ${futuresSymbol}: Pre√ßo futures $${price.toFixed(6)} (API P√∫blica)`);
        
        this.setCachedPrice(`futures_${symbol}`, price);
        return price;
      }
    } catch (error) {
      console.error(`‚ùå Erro ao buscar pre√ßo futures para ${symbol}:`, error.message);
      throw error;
    }
  }

  // üí∞ FUNDING RATE - APENAS DADOS REAIS
  async getFundingRate(symbol: string): Promise<number> {
    try {
      const binanceSymbol = symbol.replace('/', '');
      const response = await makeFetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${binanceSymbol}`);
      
      if (!response.ok) {
        // Se for erro 400, o s√≠mbolo provavelmente n√£o existe ou foi deslistado
        if (response.status === 400) {
          console.log(`‚ö†Ô∏è S√≠mbolo ${symbol} n√£o encontrado ou deslistado (400)`);
          return 0; // Retorna 0 em vez de quebrar o sistema
        }
        throw new Error(`Falha ao buscar funding rate: ${response.status}`);
      }
      
      const data = await response.json();
      const rate = parseFloat(data.lastFundingRate) || 0;
      
      return rate;
      
    } catch (error) {
      console.error(`‚ùå Erro funding rate para ${symbol}:`, error.message);
      
      // Para erros conhecidos, n√£o quebrar o sistema
      if (error.message.includes('400') || error.message.includes('Invalid symbol')) {
        console.log(`üîá Ignorando s√≠mbolo problem√°tico: ${symbol}`);
        return 0;
      }
      
      throw new Error(`N√£o foi poss√≠vel obter funding rate para ${symbol}: ${error.message}`);
    }
  }

  // üìà VOLUME 24H - APENAS DADOS REAIS
  async get24hVolume(symbol: string): Promise<number> {
    try {
      const binanceSymbol = symbol.replace('/', '');
      const response = await makeFetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${binanceSymbol}`);
      
      if (!response.ok) {
        throw new Error(`Falha ao buscar volume: ${response.status}`);
      }
      
      const data = await response.json();
      const volume = parseFloat(data.quoteVolume) || 0;
      
      return volume;
      
    } catch (error) {
      console.error(`‚ùå Erro volume para ${symbol}:`, error.message);
      
      throw new Error(`N√£o foi poss√≠vel obter volume para ${symbol}: ${error.message}`);
    }
  }

  // üéØ MARKET DATA PRINCIPAL - APENAS DADOS REAIS
  async getMarketData(symbol: string): Promise<MarketData> {
    try {
      console.log(`üìä Buscando market data para ${symbol} - PRODU√á√ÉO`);
      
      const [spotPrice, futuresPrice, fundingRate, volume] = await Promise.all([
        this.getSpotPrice(symbol),
        this.getFuturesPrice(symbol),
        this.getFundingRate(symbol),
        this.get24hVolume(symbol)
      ]);

      // Validar se todos os pre√ßos s√£o v√°lidos
      if (!spotPrice || !futuresPrice || isNaN(spotPrice) || isNaN(futuresPrice) || spotPrice <= 0 || futuresPrice <= 0) {
        throw new Error(`Pre√ßos inv√°lidos para ${symbol}: spot=${spotPrice}, futures=${futuresPrice}`);
      }

      const basis = futuresPrice - spotPrice;
      const basisPercent = spotPrice > 0 ? (basis / spotPrice) * 100 : 0;

      const marketData = {
        symbol,
        spotPrice,
        futuresPrice,
        basis,
        basisPercent,
        fundingRate: fundingRate * 100, // Convert to percentage
        volume24h: volume,
        timestamp: Date.now()
      };
      
      console.log(`‚úÖ Market data ${symbol}: Spot $${spotPrice.toFixed(4)}, Futures $${futuresPrice.toFixed(4)}, Basis ${basisPercent.toFixed(3)}%`);
      
      return marketData;
      
    } catch (error) {
      console.error(`‚ùå Erro getting market data para ${symbol}:`, error.message);
      throw error;
    }
  }

  // üìö ORDER BOOK - APENAS DADOS REAIS
  async getOrderBook(symbol: string, limit: number = 20): Promise<OrderBookData> {
    try {
      const orderBook = await this.spotExchange.fetchOrderBook(symbol, limit);
      
      if (!orderBook || !orderBook.bids || !orderBook.asks) {
        throw new Error(`Order book n√£o dispon√≠vel para ${symbol}`);
      }
      
      return {
        symbol,
        bids: orderBook.bids.slice(0, limit).map((bid: any) => [Number(bid[0]), Number(bid[1])]) as [number, number][],
        asks: orderBook.asks.slice(0, limit).map((ask: any) => [Number(ask[0]), Number(ask[1])]) as [number, number][],
        timestamp: orderBook.timestamp || Date.now()
      };
      
    } catch (error) {
      console.error(`‚ùå Erro fetching order book para ${symbol}:`, error.message);
      throw error;
    }
  }

  // üîÑ CONVERTER SYMBOL PARA FUTURES
  private convertToFuturesSymbol(symbol: string): string {
    // Binance futures format: BTC/USDT -> BTC/USDT:USDT
    if (symbol.endsWith('/USDT')) {
      return `${symbol}:USDT`;
    }
    return symbol;
  }

  // üß¶ WEBSOCKET METHODS - Para futura implementa√ß√£o
  subscribeToMarketData(symbol: string, callback: (data: MarketData) => void): void {
    this.marketDataCallbacks.set(symbol, callback);
    console.log(`üì° WebSocket subscription para ${symbol} (TODO)`);
  }

  subscribeToOrderBook(symbol: string, callback: (data: OrderBookData) => void): void {
    this.orderBookCallbacks.set(symbol, callback);
    console.log(`üì° WebSocket orderbook para ${symbol} (TODO)`);
  }

  // üõ†Ô∏è UTILIT√ÅRIOS
  getStatus(): { mode: string; networkStatus: any; cacheSize: number } {
    return {
      mode: 'PRODU√á√ÉO',
      networkStatus: getNetworkStatus(),
      cacheSize: this.priceCache.size
    };
  }

  // üí∞ BUSCAR SALDOS DA CARTEIRA (SPOT + FUTURES)
  async getAccountBalance(): Promise<any> {
    try {
      console.log('üí∞ Buscando saldos da carteira...');
      
      // üìä Buscar saldo spot
      const spotBalance = await this.spotExchange.fetchBalance();
      
      // üöÄ Buscar saldo futures
      const futuresBalance = await this.futuresExchange.fetchBalance();
      
      const balance = {
        spot: {
          USDT: {
            available: spotBalance.USDT?.free || 0,
            locked: spotBalance.USDT?.used || 0,
            total: spotBalance.USDT?.total || 0
          }
        },
        futures: {
          USDT: {
            available: futuresBalance.USDT?.free || 0,
            locked: futuresBalance.USDT?.used || 0,
            total: futuresBalance.USDT?.total || 0
          }
        }
      };
      
      console.log(`üí∞ Saldos - Spot: $${balance.spot.USDT.available} | Futures: $${balance.futures.USDT.available}`);
      return balance;
      
    } catch (error) {
      console.error('‚ùå Erro buscando saldos:', error.message);
      throw new Error(`N√£o foi poss√≠vel buscar saldos: ${error.message}`);
    }
  }

  // ‚ö° EXECUTAR ESTRAT√âGIA DE ARBITRAGEM COMPLETA
  async executeArbitrageStrategy(signal: any, usdtValue: number): Promise<any> {
    try {
      console.log(`
üéØ EXECUTANDO ARBITRAGEM REAL
   S√≠mbolo: ${signal.symbol}
   Estrat√©gia: ${signal.signal}
   Capital: $${usdtValue} USDT
   Lucro Esperado: ${signal.profitPotential?.toFixed(3)}%
      `);

      const baseSymbol = signal.symbol.replace('/USDT', '');
      const results: any = { success: false, trades: [] };

      if (signal.signal === 'long_spot_short_futures') {
        // üìà COMPRAR SPOT + VENDER FUTURES (Short)
        console.log('üìà Executando: BUY Spot + SELL Futures');
        
        // 1. Comprar no mercado spot
        const spotQuantity = usdtValue / signal.spotPrice;
        const spotOrder = await this.spotExchange.createMarketBuyOrder(signal.symbol, spotQuantity);
        
        // 2. Vender no mercado futures (short)
        const futuresOrder = await this.futuresExchange.createMarketSellOrder(`${baseSymbol}USDT`, spotQuantity);
        
        results.trades.push({ 
          type: 'spot_buy', 
          symbol: signal.symbol, 
          quantity: spotQuantity, 
          price: signal.spotPrice,
          order: spotOrder 
        });
        
        results.trades.push({ 
          type: 'futures_sell', 
          symbol: `${baseSymbol}USDT`, 
          quantity: spotQuantity, 
          price: signal.futuresPrice,
          order: futuresOrder 
        });
        
      } else if (signal.signal === 'short_spot_long_futures') {
        // üìâ VENDER SPOT + COMPRAR FUTURES (Long)
        console.log('üìâ Executando: SELL Spot + BUY Futures');
        
        // 1. Vender no mercado spot
        const spotQuantity = usdtValue / signal.spotPrice;
        const spotOrder = await this.spotExchange.createMarketSellOrder(signal.symbol, spotQuantity);
        
        // 2. Comprar no mercado futures (long)
        const futuresOrder = await this.futuresExchange.createMarketBuyOrder(`${baseSymbol}USDT`, spotQuantity);
        
        results.trades.push({ 
          type: 'spot_sell', 
          symbol: signal.symbol, 
          quantity: spotQuantity, 
          price: signal.spotPrice,
          order: spotOrder 
        });
        
        results.trades.push({ 
          type: 'futures_buy', 
          symbol: `${baseSymbol}USDT`, 
          quantity: spotQuantity, 
          price: signal.futuresPrice,
          order: futuresOrder 
        });
      }

      results.success = true;
      results.executedAt = new Date().toISOString();
      
      console.log(`‚úÖ ARBITRAGEM EXECUTADA COM SUCESSO!`);
      console.log(`üìä Resultado: ${results.trades.length} ordens executadas`);
      
      return results;
      
    } catch (error) {
      console.error('‚ùå ERRO EXECUTANDO ARBITRAGEM:', error.message);
      throw new Error(`Falha na execu√ß√£o da arbitragem: ${error.message}`);
    }
  }

  // üîÑ FECHAR POSI√á√ÉO DE ARBITRAGEM
  async closeArbitragePosition(tradeData: any): Promise<any> {
    try {
      console.log(`üîÑ Fechando posi√ß√£o de arbitragem para ${tradeData.pair}`);
      
      // Implementar l√≥gica de fechamento baseada no tipo de posi√ß√£o original
      // Por enquanto, retornar estrutura b√°sica
      return {
        success: true,
        closedAt: new Date().toISOString(),
        message: 'Posi√ß√£o fechada (implementa√ß√£o pendente)'
      };
      
    } catch (error) {
      console.error('‚ùå Erro fechando posi√ß√£o:', error.message);
      throw new Error(`Falha no fechamento: ${error.message}`);
    }
  }

  // üß™ TESTAR CONEX√ÉO API
  async testConnection(exchange: string, apiKey: string, apiSecret: string): Promise<{ success: boolean; message: string }> {
    try {
      // Para Binance, teste b√°sico de conectividade
      if (exchange === 'binance') {
        const response = await makeFetch('https://api.binance.com/api/v3/time');
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        return { success: true, message: 'Conex√£o com Binance estabelecida' };
      }
      
      return { success: false, message: 'Exchange n√£o suportada' };
      
    } catch (error) {
      return { success: false, message: `Falha na conex√£o: ${error.message}` };
    }
  }
}

// üöÄ INST√ÇNCIA GLOBAL DO EXCHANGE API
export const exchangeAPI = new ExchangeAPI();